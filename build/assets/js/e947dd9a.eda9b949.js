"use strict";(globalThis.webpackChunktemp_site=globalThis.webpackChunktemp_site||[]).push([[324],{5776:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"week-03-05-ros2/urdf-robot-description","title":"Weeks 3-5: ROS 2 Fundamentals - Creating a URDF Robot Description","description":"This document provides a comprehensive, in-depth guide to creating a Unified Robot Description Format (URDF) file from scratch. URDF is an essential XML format used in ROS 2 to describe all elements of a robot model. By the end of this tutorial, you will have a complete URDF for a simple wheeled robot and a deep understanding of each component.","source":"@site/docs/week-03-05-ros2/urdf-robot-description.md","sourceDirName":"week-03-05-ros2","slug":"/week-03-05-ros2/urdf-robot-description","permalink":"/docs/week-03-05-ros2/urdf-robot-description","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/week-03-05-ros2/urdf-robot-description.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Week 1-2 Assessment: Physical AI and Humanoid Fundamentals","permalink":"/docs/week-01-02-physical-ai/assessment"},"next":{"title":"Weeks 8-10: Advanced Simulation with Isaac Sim & the Sim-to-Real Challenge","permalink":"/docs/week-08-10-isaac/sim-to-real"}}');var l=i(4848),r=i(8453);const t={},o="Weeks 3-5: ROS 2 Fundamentals - Creating a URDF Robot Description",a={},c=[{value:"1. Introduction to URDF",id:"1-introduction-to-urdf",level:2},{value:"What is URDF?",id:"what-is-urdf",level:3},{value:"Why is it Important?",id:"why-is-it-important",level:3},{value:"Core Components of a URDF",id:"core-components-of-a-urdf",level:3},{value:"2. Our Project: A Simple Two-Wheeled Robot",id:"2-our-project-a-simple-two-wheeled-robot",level:2},{value:"3. Setting Up the URDF File",id:"3-setting-up-the-urdf-file",level:2},{value:"4. Defining Links",id:"4-defining-links",level:2},{value:"The <code>base_link</code> (Chassis)",id:"the-base_link-chassis",level:3},{value:"The Wheel Links",id:"the-wheel-links",level:3},{value:"5. Defining Joints",id:"5-defining-joints",level:2},{value:"The Wheel Joints",id:"the-wheel-joints",level:3},{value:"Creating the Rest of the Robot",id:"creating-the-rest-of-the-robot",level:3},{value:"Caster Wheel (Fixed Joint)",id:"caster-wheel-fixed-joint",level:4},{value:"Laser Scanner (Fixed Joint)",id:"laser-scanner-fixed-joint",level:4},{value:"6. The Complete URDF File",id:"6-the-complete-urdf-file",level:2},{value:"7. Next Steps: Visualizing the URDF",id:"7-next-steps-visualizing-the-urdf",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"weeks-3-5-ros-2-fundamentals---creating-a-urdf-robot-description",children:"Weeks 3-5: ROS 2 Fundamentals - Creating a URDF Robot Description"})}),"\n",(0,l.jsx)(n.p,{children:"This document provides a comprehensive, in-depth guide to creating a Unified Robot Description Format (URDF) file from scratch. URDF is an essential XML format used in ROS 2 to describe all elements of a robot model. By the end of this tutorial, you will have a complete URDF for a simple wheeled robot and a deep understanding of each component."}),"\n",(0,l.jsx)(n.h2,{id:"1-introduction-to-urdf",children:"1. Introduction to URDF"}),"\n",(0,l.jsx)(n.h3,{id:"what-is-urdf",children:"What is URDF?"}),"\n",(0,l.jsx)(n.p,{children:"The Unified Robot Description Format (URDF) is an XML specification used in ROS to describe the physical structure of a robot. It defines the robot's links (its physical parts), its joints (which connect the links), its visual appearance, and its collision properties. Tools like RViz (the ROS 2 Visualizer) and Gazebo (a physics simulator) parse this file to display and simulate the robot."}),"\n",(0,l.jsx)(n.h3,{id:"why-is-it-important",children:"Why is it Important?"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Standardization:"})," It provides a common format for describing robot kinematics and dynamics."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Visualization:"})," Tools like RViz use the URDF to render a 3D model of the robot."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Simulation:"})," Physics simulators like Gazebo use it to model the robot's behavior in a virtual world."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Kinematics & Dynamics:"})," ROS libraries for solving forward and inverse kinematics rely on the URDF to understand the robot's structure."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"core-components-of-a-urdf",children:"Core Components of a URDF"}),"\n",(0,l.jsx)(n.p,{children:"A URDF file is built around two fundamental components:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsxs)(n.strong,{children:[(0,l.jsx)(n.code,{children:"<link>"}),":"]})," A physical part of the robot. It has inertial, visual, and collision properties."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsxs)(n.strong,{children:[(0,l.jsx)(n.code,{children:"<joint>"}),":"]})," Connects two links together and defines how they can move relative to each other."]}),"\n"]}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h2,{id:"2-our-project-a-simple-two-wheeled-robot",children:"2. Our Project: A Simple Two-Wheeled Robot"}),"\n",(0,l.jsx)(n.p,{children:'We will build a URDF for a simple robot named "articubot" (a fictional articulated robot). It will have:'}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"A main chassis."}),"\n",(0,l.jsx)(n.li,{children:"Two wheels that can rotate."}),"\n",(0,l.jsx)(n.li,{children:"A caster wheel for balance."}),"\n",(0,l.jsx)(n.li,{children:'A "laser" sensor on top.'}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"This will require the following links and joints:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Links:"})," ",(0,l.jsx)(n.code,{children:"base_link"})," (chassis), ",(0,l.jsx)(n.code,{children:"left_wheel_link"}),", ",(0,l.jsx)(n.code,{children:"right_wheel_link"}),", ",(0,l.jsx)(n.code,{children:"caster_wheel_link"}),", ",(0,l.jsx)(n.code,{children:"laser_scanner_link"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Joints:"})," ",(0,l.jsx)(n.code,{children:"left_wheel_joint"}),", ",(0,l.jsx)(n.code,{children:"right_wheel_joint"}),", ",(0,l.jsx)(n.code,{children:"caster_wheel_joint"}),", ",(0,l.jsx)(n.code,{children:"laser_scanner_joint"}),"."]}),"\n"]}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h2,{id:"3-setting-up-the-urdf-file",children:"3. Setting Up the URDF File"}),"\n",(0,l.jsxs)(n.p,{children:["First, create a new file named ",(0,l.jsx)(n.code,{children:"articubot.urdf"})," in your ROS 2 package's ",(0,l.jsx)(n.code,{children:"description"})," folder."]}),"\n",(0,l.jsxs)(n.p,{children:["All URDFs start with the ",(0,l.jsx)(n.code,{children:"<robot>"})," tag, which is the root element."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="articubot">\n\n    \x3c!-- All links and joints will go here --\x3e\n\n</robot>\n'})}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"name"})," attribute of the ",(0,l.jsx)(n.code,{children:"<robot>"})," tag is the name of our robot."]}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h2,{id:"4-defining-links",children:"4. Defining Links"}),"\n",(0,l.jsxs)(n.p,{children:["A link is a rigid body with inertial, visual, and collision properties. Let's start with the robot's chassis, which we'll call ",(0,l.jsx)(n.code,{children:"base_link"}),"."]}),"\n",(0,l.jsxs)(n.h3,{id:"the-base_link-chassis",children:["The ",(0,l.jsx)(n.code,{children:"base_link"})," (Chassis)"]}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"base_link"})," is the central part of our robot. All other components will be connected to it, directly or indirectly."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-xml",children:'<link name="base_link">\n    <visual>\n        <origin xyz="0 0 0.05" rpy="0 0 0"/>\n        <geometry>\n            <box size="0.4 0.2 0.1"/>\n        </geometry>\n        <material name="blue">\n            <color rgba="0.0 0.0 0.8 1.0"/>\n        </material>\n    </visual>\n    <collision>\n        <origin xyz="0 0 0.05" rpy="0 0 0"/>\n        <geometry>\n            <box size="0.4 0.2 0.1"/>\n        </geometry>\n    </collision>\n    <inertial>\n        <origin xyz="0 0 0.05" rpy="0 0 0"/>\n        <mass value="5.0"/>\n        <inertia ixx="0.03" ixy="0.0" ixz="0.0" iyy="0.08" iyz="0.0" izz="0.1"/>\n    </inertial>\n</link>\n'})}),"\n",(0,l.jsx)(n.p,{children:"Let's break down the tags:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsxs)(n.strong,{children:[(0,l.jsx)(n.code,{children:"<visual>"}),":"]})," This defines how the link looks in RViz."]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsxs)(n.strong,{children:[(0,l.jsx)(n.code,{children:"<origin>"}),":"]})," Specifies the pose (position ",(0,l.jsx)(n.code,{children:"xyz"})," and orientation ",(0,l.jsx)(n.code,{children:"rpy"})," - roll, pitch, yaw) of the visual element relative to the link's origin. We've shifted it up slightly."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsxs)(n.strong,{children:[(0,l.jsx)(n.code,{children:"<geometry>"}),":"]})," Defines the shape. We're using a ",(0,l.jsx)(n.code,{children:"<box>"})," with dimensions ",(0,l.jsx)(n.code,{children:"length width height"}),". Other options include ",(0,l.jsx)(n.code,{children:"<cylinder>"}),", ",(0,l.jsx)(n.code,{children:"<sphere>"}),", and ",(0,l.jsx)(n.code,{children:"<mesh>"})," (for custom 3D models)."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsxs)(n.strong,{children:[(0,l.jsx)(n.code,{children:"<material>"}),":"]})," Sets the color. We've defined a blue color using RGBA values."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsxs)(n.strong,{children:[(0,l.jsx)(n.code,{children:"<collision>"}),":"]})," This defines the physical bounds of the link for physics simulation. It's crucial for Gazebo. For simple shapes, it's often identical to the ",(0,l.jsx)(n.code,{children:"<visual>"})," geometry. For complex meshes, you would use a simplified shape for the collision model to save computational resources."]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsxs)(n.strong,{children:[(0,l.jsx)(n.code,{children:"<inertial>"}),":"]})," This defines the dynamic properties of the link: its mass and rotational inertia."]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsxs)(n.strong,{children:[(0,l.jsx)(n.code,{children:"<mass>"}),":"]})," The mass of the link in kilograms."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsxs)(n.strong,{children:[(0,l.jsx)(n.code,{children:"<inertia>"}),":"]})," The 3x3 rotational inertia matrix. This describes how the link resists angular acceleration. For simple shapes, there are formulas to calculate this. For now, these are placeholder values."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"the-wheel-links",children:"The Wheel Links"}),"\n",(0,l.jsx)(n.p,{children:"Now, let's define the two main wheels. They will be identical except for their names."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-xml",children:'<link name="left_wheel_link">\n    <visual>\n        <origin rpy="1.5707 0 0"/>\n        <geometry>\n            <cylinder radius="0.05" length="0.04"/>\n        </geometry>\n        <material name="black">\n            <color rgba="0.0 0.0 0.0 1.0"/>\n        </material>\n    </visual>\n    <collision>\n        <origin rpy="1.5707 0 0"/>\n        <geometry>\n            <cylinder radius="0.05" length="0.04"/>\n        </geometry>\n    </collision>\n    <inertial>\n        <origin rpy="1.5707 0 0"/>\n        <mass value="0.5"/>\n        <inertia ixx="0.0001" ixy="0.0" ixz="0.0" iyy="0.0001" iyz="0.0" izz="0.0002"/>\n    </inertial>\n</link>\n\n<link name="right_wheel_link">\n    <visual>\n        <origin rpy="1.5707 0 0"/>\n        <geometry>\n            <cylinder radius="0.05" length="0.04"/>\n        </geometry>\n        <material name="black"/>\n    </visual>\n    <collision>\n        <origin rpy="1.5707 0 0"/>\n        <geometry>\n            <cylinder radius="0.05" length="0.04"/>\n        </geometry>\n    </collision>\n    <inertial>\n        <origin rpy="1.5707 0 0"/>\n        <mass value="0.5"/>\n        <inertia ixx="0.0001" ixy="0.0" ixz="0.0" iyy="0.0001" iyz="0.0" izz="0.0002"/>\n    </inertial>\n</link>\n'})}),"\n",(0,l.jsxs)(n.p,{children:["Notice the ",(0,l.jsx)(n.code,{children:'rpy="1.5707 0 0"'})," in the ",(0,l.jsx)(n.code,{children:"<origin>"})," tag. This rotates the cylinder by 90 degrees around the X-axis, so it stands upright like a wheel."]}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h2,{id:"5-defining-joints",children:"5. Defining Joints"}),"\n",(0,l.jsxs)(n.p,{children:["Joints connect links and define their motion. A joint connects a ",(0,l.jsx)(n.strong,{children:"parent"})," link to a ",(0,l.jsx)(n.strong,{children:"child"})," link."]}),"\n",(0,l.jsx)(n.h3,{id:"the-wheel-joints",children:"The Wheel Joints"}),"\n",(0,l.jsxs)(n.p,{children:["Let's connect the wheels to the chassis. These joints will be of type ",(0,l.jsx)(n.code,{children:"continuous"})," because a wheel can spin indefinitely."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-xml",children:'<joint name="left_wheel_joint" type="continuous">\n    <parent link="base_link"/>\n    <child link="left_wheel_link"/>\n    <origin xyz="0 0.12 0" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <dynamics damping="0.01" friction="0.1"/>\n</joint>\n\n<joint name="right_wheel_joint" type="continuous">\n    <parent link="base_link"/>\n    <child link="right_wheel_link"/>\n    <origin xyz="0 -0.12 0" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <dynamics damping="0.01" friction="0.1"/>\n</joint>\n'})}),"\n",(0,l.jsx)(n.p,{children:"Let's break down the joint tags:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsxs)(n.strong,{children:[(0,l.jsx)(n.code,{children:"name"})," and ",(0,l.jsx)(n.code,{children:"type"}),":"]})," Each joint has a unique name and a type. Common types are:","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"revolute"}),": Rotates around an axis with limits."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"continuous"}),": Rotates around an axis without limits (like a wheel)."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"prismatic"}),": Slides along an axis with limits."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"fixed"}),": Rigidly connects two links."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsxs)(n.strong,{children:[(0,l.jsx)(n.code,{children:"<parent>"})," and ",(0,l.jsx)(n.code,{children:"<child>"}),":"]})," Defines the kinematic chain. The ",(0,l.jsx)(n.code,{children:"child"})," link's pose is defined relative to the ",(0,l.jsx)(n.code,{children:"parent"})," link's pose."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsxs)(n.strong,{children:[(0,l.jsx)(n.code,{children:"<origin>"}),":"]})," Defines the pose of the child link's origin relative to the parent link's origin. For the ",(0,l.jsx)(n.code,{children:"left_wheel_joint"}),", we place it at ",(0,l.jsx)(n.code,{children:"y=0.12"}),", which is to the left of the chassis's center."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsxs)(n.strong,{children:[(0,l.jsx)(n.code,{children:"<axis>"}),":"]})," The axis of rotation for ",(0,l.jsx)(n.code,{children:"revolute"})," and ",(0,l.jsx)(n.code,{children:"continuous"})," joints, or the axis of translation for ",(0,l.jsx)(n.code,{children:"prismatic"})," joints. Here, ",(0,l.jsx)(n.code,{children:"0 1 0"})," means the wheels will rotate around the Y-axis."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsxs)(n.strong,{children:[(0,l.jsx)(n.code,{children:"<dynamics>"}),":"]})," (Optional) Defines physical properties like ",(0,l.jsx)(n.code,{children:"damping"})," and ",(0,l.jsx)(n.code,{children:"friction"})," for simulation."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"creating-the-rest-of-the-robot",children:"Creating the Rest of the Robot"}),"\n",(0,l.jsx)(n.p,{children:"Now we apply the same principles to create the caster wheel and the laser scanner."}),"\n",(0,l.jsx)(n.h4,{id:"caster-wheel-fixed-joint",children:"Caster Wheel (Fixed Joint)"}),"\n",(0,l.jsx)(n.p,{children:"For simplicity, our caster wheel won't rotate; it will be fixed to the chassis."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-xml",children:'<link name="caster_wheel_link">\n    <visual>\n        <geometry>\n            <sphere radius="0.03"/>\n        </geometry>\n        <material name="grey">\n            <color rgba="0.5 0.5 0.5 1.0"/>\n        </material>\n    </visual>\n    <collision>\n        <geometry>\n            <sphere radius="0.03"/>\n        </geometry>\n    </collision>\n    <inertial>\n        <mass value="0.2"/>\n        <inertia ixx="0.00001" ixy="0.0" ixz="0.0" iyy="0.00001" iyz="0.0" izz="0.00001"/>\n    </inertial>\n</link>\n\n<joint name="caster_wheel_joint" type="fixed">\n    <parent link="base_link"/>\n    <child link="caster_wheel_link"/>\n    <origin xyz="-0.15 0 -0.02"/>\n</joint>\n'})}),"\n",(0,l.jsxs)(n.p,{children:["Since the ",(0,l.jsx)(n.code,{children:"type"})," is ",(0,l.jsx)(n.code,{children:"fixed"}),", we don't need an ",(0,l.jsx)(n.code,{children:"<axis>"})," or ",(0,l.jsx)(n.code,{children:"<dynamics>"})," tag."]}),"\n",(0,l.jsx)(n.h4,{id:"laser-scanner-fixed-joint",children:"Laser Scanner (Fixed Joint)"}),"\n",(0,l.jsx)(n.p,{children:'Finally, let\'s add a "sensor" to the top.'}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-xml",children:'<link name="laser_scanner_link">\n    <visual>\n        <geometry>\n            <box size="0.05 0.05 0.1"/>\n        </geometry>\n        <material name="red">\n            <color rgba="0.8 0.0 0.0 1.0"/>\n        </material>\n    </visual>\n    <collision>\n        <geometry>\n            <box size="0.05 0.05 0.1"/>\n        </geometry>\n    </collision>\n    <inertial>\n        <mass value="0.1"/>\n        <inertia ixx="0.0001" ixy="0.0" ixz="0.0" iyy="0.0001" iyz="0.0" izz="0.0001"/>\n    </inertial>\n</link>\n\n<joint name="laser_scanner_joint" type="fixed">\n    <parent link="base_link"/>\n    <child link="laser_scanner_link"/>\n    <origin xyz="0.15 0 0.15"/>\n</joint>\n'})}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h2,{id:"6-the-complete-urdf-file",children:"6. The Complete URDF File"}),"\n",(0,l.jsxs)(n.p,{children:["Here is the complete ",(0,l.jsx)(n.code,{children:"articubot.urdf"})," file. You can copy and paste this into your file."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="articubot">\n\n    \x3c!-- Materials --\x3e\n    <material name="blue">\n        <color rgba="0.0 0.0 0.8 1.0"/>\n    </material>\n    <material name="black">\n        <color rgba="0.0 0.0 0.0 1.0"/>\n    </material>\n    <material name="grey">\n        <color rgba="0.5 0.5 0.5 1.0"/>\n    </material>\n    <material name="red">\n        <color rgba="0.8 0.0 0.0 1.0"/>\n    </material>\n\n    \x3c!-- Base Link (Chassis) --\x3e\n    <link name="base_link">\n        <visual>\n            <origin xyz="0 0 0.05" rpy="0 0 0"/>\n            <geometry>\n                <box size="0.4 0.2 0.1"/>\n            </geometry>\n            <material name="blue"/>\n        </visual>\n        <collision>\n            <origin xyz="0 0 0.05" rpy="0 0 0"/>\n            <geometry>\n                <box size="0.4 0.2 0.1"/>\n            </geometry>\n        </collision>\n        <inertial>\n            <origin xyz="0 0 0.05" rpy="0 0 0"/>\n            <mass value="5.0"/>\n            <inertia ixx="0.03" ixy="0.0" ixz="0.0" iyy="0.08" iyz="0.0" izz="0.1"/>\n        </inertial>\n    </link>\n\n    \x3c!-- Wheel Links --\x3e\n    <link name="left_wheel_link">\n        <visual>\n            <origin rpy="1.5707 0 0"/>\n            <geometry>\n                <cylinder radius="0.05" length="0.04"/>\n            </geometry>\n            <material name="black"/>\n        </visual>\n        <collision>\n            <origin rpy="1.5707 0 0"/>\n            <geometry>\n                <cylinder radius="0.05" length="0.04"/>\n            </geometry>\n        </collision>\n        <inertial>\n            <origin rpy="1.5707 0 0"/>\n            <mass value="0.5"/>\n            <inertia ixx="0.0001" ixy="0.0" ixz="0.0" iyy="0.0001" iyz="0.0" izz="0.0002"/>\n        </inertial>\n    </link>\n\n    <link name="right_wheel_link">\n        <visual>\n            <origin rpy="1.5707 0 0"/>\n            <geometry>\n                <cylinder radius="0.05" length="0.04"/>\n            </geometry>\n            <material name="black"/>\n        </visual>\n        <collision>\n            <origin rpy="1.5707 0 0"/>\n            <geometry>\n                <cylinder radius="0.05" length="0.04"/>\n            </geometry>\n        </collision>\n        <inertial>\n            <origin rpy="1.5707 0 0"/>\n            <mass value="0.5"/>\n            <inertia ixx="0.0001" ixy="0.0" ixz="0.0" iyy="0.0001" iyz="0.0" izz="0.0002"/>\n        </inertial>\n    </link>\n\n    \x3c!-- Caster Wheel Link --\x3e\n    <link name="caster_wheel_link">\n        <visual>\n            <geometry>\n                <sphere radius="0.03"/>\n            </geometry>\n            <material name="grey"/>\n        </visual>\n        <collision>\n            <geometry>\n                <sphere radius="0.03"/>\n            </geometry>\n        </collision>\n        <inertial>\n            <mass value="0.2"/>\n            <inertia ixx="0.00001" ixy="0.0" ixz="0.0" iyy="0.00001" iyz="0.0" izz="0.00001"/>\n        </inertial>\n    </link>\n\n    \x3c!-- Laser Scanner Link --\x3e\n    <link name="laser_scanner_link">\n        <visual>\n            <geometry>\n                <box size="0.05 0.05 0.1"/>\n            </geometry>\n            <material name="red"/>\n        </visual>\n        <collision>\n            <geometry>\n                <box size="0.05 0.05 0.1"/>\n            </geometry>\n        </collision>\n        <inertial>\n            <mass value="0.1"/>\n            <inertia ixx="0.0001" ixy="0.0" ixz="0.0" iyy="0.0001" iyz="0.0" izz="0.0001"/>\n        </inertial>\n    </link>\n\n    \x3c!-- Joints --\x3e\n    <joint name="left_wheel_joint" type="continuous">\n        <parent link="base_link"/>\n        <child link="left_wheel_link"/>\n        <origin xyz="0 0.12 0" rpy="0 0 0"/>\n        <axis xyz="0 1 0"/>\n        <dynamics damping="0.01" friction="0.1"/>\n    </joint>\n\n    <joint name="right_wheel_joint" type="continuous">\n        <parent link="base_link"/>\n        <child link="right_wheel_link"/>\n        <origin xyz="0 -0.12 0" rpy="0 0 0"/>\n        <axis xyz="0 1 0"/>\n        <dynamics damping="0.01" friction="0.1"/>\n    </joint>\n\n    <joint name="caster_wheel_joint" type="fixed">\n        <parent link="base_link"/>\n        <child link="caster_wheel_link"/>\n        <origin xyz="-0.15 0 -0.02"/>\n    </joint>\n\n    <joint name="laser_scanner_joint" type="fixed">\n        <parent link="base_link"/>\n        <child link="laser_scanner_link"/>\n        <origin xyz="0.15 0 0.15"/>\n    </joint>\n\n</robot>\n'})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsxs)(n.em,{children:["Note: Defining reusable ",(0,l.jsx)(n.code,{children:"<material>"})," tags at the top level is good practice, though some older parsers might not support it. For maximum compatibility, you can define the ",(0,l.jsx)(n.code,{children:"<material>"})," tag within each ",(0,l.jsx)(n.code,{children:"<visual>"})," block."]})}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h2,{id:"7-next-steps-visualizing-the-urdf",children:"7. Next Steps: Visualizing the URDF"}),"\n",(0,l.jsxs)(n.p,{children:["With this file created, the next step is to visualize it in RViz. This requires creating a ROS 2 launch file that starts the ",(0,l.jsx)(n.code,{children:"robot_state_publisher"})," and ",(0,l.jsx)(n.code,{children:"joint_state_publisher"})," nodes, which read the URDF and publish the robot's transformations."]}),"\n",(0,l.jsx)(n.p,{children:"This concludes our deep dive into creating a URDF file. You now have a solid foundation for describing any robot in ROS 2."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>o});var s=i(6540);const l={},r=s.createContext(l);function t(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:t(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);